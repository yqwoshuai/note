# 第五章、非原始值的响应式方案

## 代理对象Object

Vue3 还可以对 for...in 循环进行拦截，还可以对集合类型 Map Set WeakMap WeakSet 进行代理。

可以代理 apply 操作来拦截函数的调用

```js
const fn = (str) => {
  console.log(str)
}

const pFn = new Proxy(fn, {
  apply(target, thisArg, argArray) {
    console.log('函数调用')
    target.call(thisArg, ...argArray)
  },
})

// 输出:
// 函数调用
// 123
pFn('123')
```

原来的 get 代理中，直接使用了`target[key]`进行返回，这会出现 this 指向问题

```js
// 原始数据
const data = {
  foo: 1,
  get bar() {
    return this.foo
  },
}

const obj = new Proxy({
  // 代理操作
})

effect(() => {
  console.log(obj.bar)
})

// 不会触发副作用函数
obj.foo++

// 在代理对象get操作时，使用target[key]返回结果，target指向的是原始对象，访问bar的时候访问了this.foo
// 而此时的this指向的是原始对象target，所以target[key]就是data.foo，副作用函数就变成了
// effect(() => {
//   console.log(data.foo)
// })
// data.foo不是响应式属性，不会触发依赖的收集，也就不会触发副作用函数的执行
```

使用 Reflect 全局对象，来实现对各种操作的代理。

```js
const obj = new Proxy(data, {
  // 拦截读取操作接受第三个参数receiver，表示实际访问属性的是哪个对象，可以理解为当前this的指向
  get(target, key, receiver) {
    track(target, key)
    // 使用 Reflect返回属性值，传入第三个参数receiver改变this的指向
    return Reflect.get(target, key, receiver)
  },
  set(target, key, newVal, receiver) {
    // 使用 Reflect设置属性值
    const res = Reflect.set(target, key, newVal, receiver)
    trigger(target, key)
    // 返回设置的结果
    return res
  },
})

effect(() => {
  console.log(obj.bar)
})

// 会触发副作用函数
obj.foo++
```

对象在执行各种操作时，本质上是执行了内部的各种方法。例如读取属性，本质是执行了对象内部的[[Get]]方法，代理对象就可以通过重写 get 方法来覆盖内部[[Get]]方法的默认行为。

所以说代理对象本质上是通过各种自定义方法，来代理对象上面各种操作实际执行的内部方法。例如删除操作，本质上是代理对象内部的 deleteProperty 方法：

```js
const obj = new Proxy(data, {
  // 自定义 deleteProperty 方法，拦截delete操作
  deleteProperty(target, key) {
    console.log('删除属性')
    // 通过Reflect上的deleteProperty方法执行删除操作
    return Reflect.deleteProperty(target, key)
  },
})

// 输出 删除属性
delete obj.foo
```

通过 has 方法拦截 in 操作符

```js
const obj = new Proxy(data, {
  has(target, key) {
    // in 操作符触发时，收集依赖
    track(target, key)
    return Reflect.has(target, key)
  },
})
effect(() => {
  // in 操作符也属于 读取 操作，需要收集依赖
  'foo' in obj
  console.log('执行')
})

// 副作用函数会被触发
obj.foo++
```

对于 for...in 操作，其实是在内部调用了`Reflect.ownKeys(obj)`来获取只属于对象自身拥有的键，所以需要对`Reflect.ownKeys`操作进行拦截。

```js
// 因为 ownKeys 拦截没有对应的key，所以定一个Symbol值来收集ownKeys触发时对应的依赖
const ITERATE_KEY = Symbol()
// 对原始数据的代理
const obj = new Proxy(data, {
  ownKeys(target) {
    // 使用Symbol值来收集依赖
    track(target, ITERATE_KEY)
    return Reflect.ownKeys(target)
  },
})

function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  // 触发依赖时，将通过ITERATE_KEY收集到的依赖也取出
  const iterateEffect = depsMap.get(ITERATE_KEY)
  const effectsToRun = new Set()

  effects &&
    effects.forEach((fn) => {
      if (fn !== activeEffect) {
        effectsToRun.add(fn)
      }
    })
  // 执行ITERATE_KEY收集到的依赖
  iterateEffect &&
    iterateEffect.forEach((fn) => {
      if (fn !== activeEffect) {
        effectsToRun.add(fn)
      }
    })
  effectsToRun.forEach((fn) => {
    if (fn.options.scheduler) {
      fn.options.scheduler(fn)
    } else {
      fn()
    }
  })
}

effect(() => {
  // 执行for...in操作，通过ownKeys拦截
  for (const key in obj) {
    console.log(key)
  }
})

// 新增属性，会导致for...in操作需要遍历的次数改变，所以副作用函数需要重新执行
obj.bar = 2
```

现在即使只是修改 obj 上原有的属性，不新增属性，理论上来说 for...in 操作遍历的次数不会改变，所以不需要重新执行。但是由于设置属性和新增属性，都是通过拦截 set 操作实现的。
所以需要在 set 操作内部对当前的操作作区分。判断当前到底是新增，该是修改。

```js
// 定义常量来表示各种操作
const TriggerType = {
  SET: 'SET',
  ADD: 'ADD',
}

const obj = new Proxy(data, {
  set(target, key, newVal, receiver) {
    // 判断当前属性是否已经存在，如果存在的话表示是修改属性，如果不存在则表示是新增属性
    const type = Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD
    const res = Reflect.set(target, key, newVal, receiver)
    // 触发响应时将当前的操作类型传入
    trigger(target, key, type)

    return res
  },
})

function trigger(target, key, type) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  const effectsToRun = new Set()

  effects &&
    effects.forEach((fn) => {
      if (fn !== activeEffect) {
        effectsToRun.add(fn)
      }
    })
  // 当前的操作为新增时，执行对应的响应
  if (type === TriggerType.ADD) {
    const iterateEffect = depsMap.get(ITERATE_KEY)
    iterateEffect &&
      iterateEffect.forEach((fn) => {
        if (fn !== activeEffect) {
          effectsToRun.add(fn)
        }
      })
  }
  effectsToRun.forEach((fn) => {
    if (fn.options.scheduler) {
      fn.options.scheduler(fn)
    } else {
      fn()
    }
  })
}
```

删除属性时，也要做这种判断。

```js
const obj = new Proxy(data, {
  deleteProperty(target, key) {
    // 判断被删除的key是否存在
    const hadKey = Object.prototype.hasOwnProperty.call(target, key)
    // 执行删除
    const res = Reflect.deleteProperty(target, key)
    // key存在且删除成功时触发响应，并传入操作类型
    if (res && hadKey) {
      trigger(target, key, TriggerType.DELETE)
    }
    return
  },
})

function trigger(target, key, type) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  const iterateEffect = depsMap.get(ITERATE_KEY)
  const effectsToRun = new Set()

  effects &&
    effects.forEach((fn) => {
      if (fn !== activeEffect) {
        effectsToRun.add(fn)
      }
    })
  // DELETE表示执行删除操作，for...in遍历的次数会变少，也要重新执行
  if (type === TriggerType.ADD || type === TriggerType.DELETE) {
    iterateEffect &&
      iterateEffect.forEach((fn) => {
        if (fn !== activeEffect) {
          effectsToRun.add(fn)
        }
      })
  }
  effectsToRun.forEach((fn) => {
    if (fn.options.scheduler) {
      fn.options.scheduler(fn)
    } else {
      fn()
    }
  })
}

effect(() => {
  for (const key in obj) {
    console.log(key)
  }
})

// 删除属性，for...in遍历的次数会变少，重新执行
delete obj.foo
```

当修改的属性值与之前相等时，理论上属性值没有变化，不应该触发副作用函数的执行。所以修改值时需要对新旧值做对比。

```js
const obj = new Proxy(data, {
  set(target, key, newVal, receiver) {
    // 取出旧值
    const oldVal = target[key]
    const type = Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD
    const res = Reflect.set(target, key, newVal, receiver)
    // 新旧值对比，只有不全等时才触发响应，还要注意对NaN做额外判断
    if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
      trigger(target, key, type)
    }

    return res
  },
})

effect(() => {
  console.log(obj.foo)
})

// foo本来就是1，修改为1不会触发响应
obj.foo = 1
```

当从原型上继承属性时，会造成不必要的更新。

```js
// 封装成函数方便调用
function reactive(data) {
  return new Proxy(data, {
    // 代理操作
  })
}

const obj1 = { foo: 1 }
const obj2 = { bar: 2 }
const child = reactive(obj1)
const parent = reactive(obj2)

// 修改child的原型为parent
Object.setPrototypeOf(child, parent)

effect(() => {
  console.log(child.bar)
})

// 修改child原型上的属性，会发现副作用函数执行了两次，输出了两个3
child.bar = 3
console.log(bar)
```

修改 bar 属性，实际上会去调用原型上的属性做 set 操作，所以触发了 parent 的 set 拦截。
执行 parent 的 set 操作时，传入的 target 和 receiver 代表的对象不一致，target 指向了 parent 的原始对象 obj2，但是 receiver 指向的却是 obj1 的代理对象 child。所以可以在这里对其做区分。
增加一个属性来判断当前的代理对象代理的是否是当前的原始对象。即 receiver 代理的是否是 target。

```js
function reactive(data) {
  return new Proxy(data, {
    get(target, key, receiver) {
      // 增加一个 raw 属性，用来返回当前正在代理的原始对象
      if (key === 'raw') {
        return target
      }
      track(target, key)
      return Reflect.get(target, key, receiver)
    },
    //
    set(target, key, newVal, receiver) {
      const oldVal = target[key]
      const type = Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD
      const res = Reflect.set(target, key, newVal, receiver)
      // 判断当前代理对象所代理的是不是当前的原始对象，只有代理对象代理的是当前的原始对象时，才需要触发响应
      if (target === receiver.raw) {
        if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
          trigger(target, key, type)
        }
      }

      return res
    },
  })
}
```

目前的响应形式是浅响应，也就是说对深处的属性做修改的话无法触发响应。

```js
const obj = reactive({ foo: { bar: 1 } })

effect(() => {
  console.log(obj.foo.bar)
})
// 修改深层属性无法触发响应
obj.foo.bar = 2
```

需要对深层的属性做递归代理操作：

```js
function reactive(data) {
  return new Proxy(data, {
    get(target, key, receiver) {
      if (key === 'raw') {
        return target
      }
      track(target, key)
      // 获取属性值，判断是否为对象，为对象则递归代理
      const res = Reflect.get(target, key, receiver)
      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }
      return res
    },
  })
}
```

有的时候我们只需要浅响应就够了，所以需要一个传参来决定当前到底使用浅响应还是深响应。

```js
// 封装统一的代理创建函数，新增参数用来判断是否创建浅响应
function createReactive(data, isShallow = false) {
  return new Proxy(data, {
    get(target, key, receiver) {
      if (key === 'raw') {
        return target
      }
      track(target, key)
      const res = Reflect.get(target, key, receiver)
      // 如果只需要浅响应则直接返回结果
      if (isShallow) {
        return res
      }
      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }
      return res
    },
  })
}

// 深响应
function reactive(data) {
  return createReactive(data)
}

// 浅响应
function shallowReactive(data) {
  return createReactive(data, false)
}
```

有时我们希望创建只读的响应数据，修改只读的数据时报出警告。

```js
// 新增参数用来判断是否创建只读属性
function createReactive(data, isShallow = false, isReadonly = false) {
  return new Proxy(data, {
    get(target, key, receiver) {
      if (key === 'raw') {
        return target
      }
      // 只读属性不需要收集依赖
      if (!isReadonly) {
        track(target, key)
      }
      const res = Reflect.get(target, key, receiver)
      if (isShallow) {
        return res
      }
      if (typeof res === 'object' && res !== null) {
        // 如果不是浅响应，表示深层的属性也要变为只读的，所以要递归调用只读
        return isReadonly ? readonly(res) : reactive(res)
      }
      return res
    },
    set(target, key, newVal, receiver) {
      // 只读属性不允许修改，报出警告
      if (isReadonly) {
        console.warn(`属性${key}是只读的`)
        return true
      }
      const oldVal = target[key]
      const type = Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD
      const res = Reflect.set(target, key, newVal, receiver)
      if (target === receiver.raw) {
        if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
          trigger(target, key, type)
        }
      }

      return res
    },
    deleteProperty(target, key) {
      // 只读属性不允许删除，报出警告
      if (isReadonly) {
        console.warn(`属性${key}是只读的`)
        return true
      }
      const hadKey = Object.prototype.hasOwnProperty.call(target, key)
      const res = Reflect.deleteProperty(target, key)
      if (res && hadKey) {
        trigger(target, key, TriggerType.DELETE)
      }
      return
    },
  })
}

// 深只读
function readonly(data) {
  return createReactive(data, false, true)
}

// 浅只读
function shallowReadonly(data) {
  return createReactive(data, true, true)
}

const obj = readonly({ foo: { bar: 1 } })

effect(() => {
  console.log(obj.foo.bar)
})

// 修改深层属性报出警告
obj.foo.bar = 2
```

## 代理数组Array

