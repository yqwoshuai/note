# 第十二章、组件的实现原理

组件的本质是一个选项对象，他包含了组件的各种数据配置，在 vnode 中，这个选项对象会储存在 type 属性上。

```js
const Mycomponent = {
  name: 'Mycomponent',
  data() {
    return {
      foo: 'hello world',
    }
  },
  // 组件模板会被编译为render函数
  render() {
    return {
      type: 'div',
      children: `foo的值为${this.foo}`,
    }
  },
}

// 编译为vnode
const compVnode = {
  type: Mycomponent,
}

// 渲染
renderer.render(compVnode, document.querySelector('#app'))
```

组件的 vnode 拥有特殊的 type 属性，在 patch 的时候对其做特殊处理。

```js
function patch(n1, n2, container) {
  if (n1 && n1.type !== n2.type) {
    unmount(n1)
    n1 = null
  }

  const { type } = n2

  if (typeof type === 'string') {
    ///
  } else if (typeof type === 'object') {
    // type的类型是object的话表示是一个组件
    if (!n1) {
      // 绑定组件
      mountComponent(n2, container)
    } else {
      // 更新组件
      patchComponent(n1, n2)
    }
  } else if (type === Text) {
    ///
  } else if (type === Fragment) {
    ///
  }
}

// 同样使用一个微任务队列来执行渲染，防止数据的频繁变动导致的渲染函数多次调用
const queue = new Set()
let isFlushing = false
const p = Promise.resolve()
function queueJob(job) {
  queue.add(job)
  if (!isFlushing) {
    isFlushing = true
    p.then(() => {
      try {
        queue.forEach((job) => job())
      } finally {
        isFlushing = false
        queue.clear()
      }
    })
  }
}

function mountComponent(vnode, container) {
  // 取出组件的配置信息
  const componentOptions = vnode.type
  const { render, data } = componentOptions

  // 将组件数据转化为响应式数据
  const state = reactive(data())

  // 使用effect包装渲染任务，这样响应式数据变化后，重新执行副作用函数渲染组件
  effect(
    () => {
      // call绑定渲染函数执行时的this指向，获取render函数返回的vnode进行渲染
      const subTree = render.call(state, state)
      patch(null, subTree, container)
    },
    {
      // 自定义调度函数
      scheduler: queueJob,
    }
  )
}
```

目前我们的 mountComponent 函数内部在调用 patch 函数渲染时，传入的第一个参数总是 null，也就是说每次更新都会是全新的挂载，而不会进行补丁操作。所以我们需要实现一个组件的实例，这个实例用来维护整个组件的生命周期。

```js
function mountComponent(vnode, container) {
  const componentOptions = vnode.type

  // 取出组件的各种生命周期
  const { render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated } = componentOptions

  // 执行创建组件实例前的生命周期
  beforeCreate && beforeCreate()

  const state = reactive(data())

  // 定义组件实例，上面有各种表示当前组件状态的属性
  const instance = {
    state,
    isMounted: false,
    subTree: null,
  }

  // 将实例挂载到vnode上面，方便之后其他地方访问
  vnode.component = instance
  // 创建组件完成的生命周期，注意在这个生命周期开始，可以访问state上面的数据了，所以要绑定一下其中this的指向，之后的生命周期也一样
  created && created.call(state)

  effect(
    () => {
      const subTree = render.call(state, state)
      // 根据isMounted属性判断当前是挂载还是更新，并执行对应的生命周期
      if (!instance.isMounted) {
        beforeMount && beforeMount.call(state)
        patch(null, subTree, container)
        instance.isMounted = true
        mounted && mounted.call(state)
      } else {
        beforeUpdate && beforeUpdate.call(state)
        patch(instance.subTree, subTree, container)
        updated && updated.call(state)
      }

      // 渲染完成后更新实例上面的subTree
      instance.subTree = subTree
    },
    {
      scheduler: queueJob,
    }
  )
}
```

组件会显式的指定需要接收的 props，但是调用组件的时候也可以传组件没有指定的 props，这需要我们对其做区分。

```js
// 使用组件时可能传多个props
// <MyComponent title="this is titile" :other="val" />

// 上面的模板会被编译为这样的vnode
const compVnode = {
  type: Mycomponent,
  props: {
    title: 'this is title',
    other: this.val,
  },
}

// 在组件内部，只显式的接收了title属性
const Mycomponent = {
  name: 'Mycomponent',
  props: {
    // 只接收了title属性，而且规定为string类型
    title: String,
  },
  render() {
    return {
      type: 'div',
      children: `title的值为${this.title}`,
    }
  },
}

// 存在两个props属性，一个是vnode上的，也就是我们实际使用组件时传入的，一个是组件描述对象上的，也就是组件实际接收的
// 我们要对这两个props做处理，只有定义在组件内部的props，才是组件需要的，其他的props将其转换为attrs
function mountComponent(vnode, container) {
  const componentOptions = vnode.type
  // 取出组件上的props属性
  const { props: propsOptions } = componentOptions

  ///

  // 将其与vnode上的props进行格式化
  const [props, attrs] = resolveProps(propsOptions, vnode.props)

  const instance = {
    state,
    isMounted: false,
    // props包装成浅响应数据
    props: shallowReactive(props),
    subTree: null,
  }

  ///
}

// 格式化props，将其区分为组件实际接收的props和attrs
function resolveProps(options, propsData) {
  const props = {}
  const attrs = {}
  for (const key in propsData) {
    if (key in options) {
      props[key] = propsData[key]
    } else {
      attrs[key] = propsData[key]
    }
  }

  return [props, attrs]
}
```

父节点的 props 变化的时候，会导致父组件的更新，渲染器更新父节点的子节点时，会发现包含组件类型的子节点，就会执行 patchComponent 操作。

```js
function patchComponent(n1, n2) {
  // 获取conponent实例，并更新到n2上
  const instance = (n2.component = n1.component)
  // 取出props属性
  const { props } = instance
  // 判断props属性是否需要更新
  if (hasPropsChanged(n1.props, n2.props)) {
    // 分别从n2的组件对象和n2的vnode上取出props属性，重新格式化
    const [nextProps] = resolveProps(n2.type.props, n2.props)
    // 更新props
    for (const key in nextProps) {
      props[key] = nextProps[key]
    }
    // 已经没有的props删除掉
    for (const key in props) {
      if (!(key in nextProps)) delete props[key]
    }
  }
}

// 判断props属性是否需要更新
function hasPropsChanged(prevProps, nextProps) {
  const nextKeys = Object.keys(nextProps)
  // key的长度不一样了，表示有新增或者减少key，需要更新
  if (nextKeys.length !== Object.keys(propsData).length) {
    return true
  }

  // 长度一致则判断key的值是否相同，不同则需要更新
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i]
    if (nextProps[key] !== prevProps[key]) return true
  }

  return false
}

// attrs属性的更新和props类似
```

因为我们可以通过 this.xxx 同时访问定义在 props 属性和 state 属性上的值，所以需要我们对 instance 实例作统一的代理。

```js
function mountComponent(vnode, container) {
  ///

  vnode.component = instance

  // 对我们的实例作代理，使得this可以同时访问state和props
  // 从代理的过程也可以看出如果组件上的data和props出现了同名属性，data上的属性优先级更高
  const renderContext = new Proxy(instance, {
    get(target, key) {
      const { state, props } = target
      if (state && key in state) {
        return state[key]
      } else if (key in props) {
        return props[key]
      } else {
        console.log('属性不存在')
      }
    },
    set(target, key, value) {
      const { state, props } = target
      if (state && key in state) {
        state[key] = value
      } else if (key in props) {
        props[key] = value
      } else {
        console.log('属性不存在')
      }
    },
  })

  // 执行生命周期时this指向我们的代理对象，其他生命周期同理
  created && created.call(renderContext)

  ///
}
```
