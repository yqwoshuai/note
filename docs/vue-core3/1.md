# 1、Vue3.0做的优化

## 代码结构

1. 使用了`monorepo`的方式管理代码，根据功能将不同的模块拆分到了packages目录下的不同子目录中，模块拆分更加细化。
2. 使用了`Typescript`编写源码，比vue2使用的Flow更好的类型检查和更加复杂的类型推导。

## 性能优化

1. 体积优化，vue3去掉了一些冷门的 feature（filter、inline-template 等）。
2. 引入了`tree-shaking`技术，减少的代码打包的体积。tree-shaking会对没有引用的export做标记，在webpack使用uglify-js这类压缩代码的工具的时候，会删除掉这些被tree-shaking标记的代码。例如当你没有引用Transition、KeepAlive这些内置组件的时候，它们就不会被打包。

3. 数据劫持优化，vue2通过`Object.defineProperty`API实现对数据的劫持，将数据转为响应式的，但是这种方式必须知道要劫持的key是什么，不能直接劫持整个对象，导致新增和删除key的时候只能通过vue2提供的 $set 和 $delete实例方法。vue3使用的是`Proxy`API，直接劫持整个对象，不用管对象的具体属性，并且在getter中递归处理，当Proxy内部有深层次的对象时，只有访问到了具体的对象才会变成响应式。

4. 编译优化，vue2在触发更新时，在单个组件内仍然需要便利整个vnode树，当当前vnode树中有很多静态的节点时，这些遍历都是没有必要的。vue3通过在编译阶段生成`Block tree`，使得更新组件时只会更新动态节点，节省了没有必要的遍历。

## 语法优化

1. 提供了新的`Composition  API`，vue2使用的是Options API，当某个组件有多个功能时，各个功能使用的数据会集中在data中，逻辑会分散在各个生命周期以及methods中。而vue3的Composition  API能够将某个功能相关的数据和逻辑都集中在一个函数里。使得整个组件的代码会根据功能的不同进行划分。

2. vue2使用多个mixins时，会导致mixins的命名冲突和来源不清晰问题。vue3可以通过Composition API实现自定义hooks，解决命名冲突和来源不清晰的问题。
